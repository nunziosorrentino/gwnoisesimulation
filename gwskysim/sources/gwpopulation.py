import os
import importlib
import pandas as pd
import numpy as np
from gwskysim.sources.gwsignal import GWSignal
from gwskysim.sources.gwcolored_noise import GWColoredNoise
from gwskysim.sources.gwwhitenoise import White_gaussian_noise
from scipy import interpolate

# custom import
from gwskysim import GWSKYSIM_CONF 
from gwskysim.utilities.gwlogger import GWLogger

pop_logger = GWLogger("pop_logger")
pop_logger.set_loglevel("INFO")


class GWPopulation:
    """An iterable class containing a population of GW sources ready for
       the simulation.
    """
    available_noises = [None, 'white', 'colored']

    def __init__(self, *elements):
        """Constructor.
        """

        if elements==():
            self.name = ''
            self._elements = 0
            self.sources = None
        else:    
            self._elements = list(elements)
            params_dfs = []
            for f in self._elements:
                params_df = pd.read_hdf(f, 'df_sources_parameters')
                params_dfs.append(params_df)
            self.sources = pd.concat(params_dfs, ignore_index=True, 
                                     sort=False)
            self.name = '{}-{}'.format(self.sources.iloc[0]['id'],
                                       self.sources.iloc[-1]['id'])                         
            #print(self.sources)
        

    def __len__(self):
        """Len of a gwpopulation is the number of sources
        """
        if self.sources is None:
            return 0
        else:    
            return self.sources.shape[0]


    def generate_noise(self, m_start_time, m_duration, m_sample_rate,
                       detectors=['H1', 'L1', 'V1'], noise=None):
        """
        This is a method that create the base to the time-series generated by gwskysim. If colored
        is True, it generates a noise time-series, given by the sensitive curve of the
        specified detectors. If colored is False, a zeros base in generated.
        """
        assert (noise in self.available_noises)
        if noise == 'colored':
            gw_noise = []
            for di in detectors:
                pop_logger.info('Generating Colored Noise background from {} Amplitude Spectral Density!'.format(di))
                try:
                    asd_file = os.path.join(GWSKYSIM_CONF, "{}_asd_smth.txt".format(di))
                    f_l, asd_l = np.loadtxt(asd_file, unpack=True)

                    asd_interp = interpolate.interp1d(f_l, np.log10(asd_l))
                    fmax = np.amax(f_l) - 1
                    fmin = f_l[0]
                    duration = np.abs(m_duration)
                    samples = None
                    # samples = None in colored noise si setta di default samples=len(times_array) direttamente in __call__
                    # Qui ci potremmo mettere un messaggio di log, per indicare il loading del rumore colorato
                    d_colnoise = GWColoredNoise('Colored Noise', samples, asd_interp, fmin, fmax) 
                    det_noise = d_colnoise.generate_signal(m_start_time, m_duration, m_sample_rate, detectors=[di])[0]
                except OSError as e:
                    print("WARNING!! {} accourred when loading {} sensibility file. No Noise considered for the detector!".format(e, di))
                    det_noise = GWSignal('No Noise', m_start_time, m_duration, m_sample_rate, detector=di)   
                gw_noise.append(det_noise)
            pop_logger.info('Done!!!')     
        if noise == 'white':
            gw_noise = []
            for di in detectors:
                d_whinoise = White_gaussian_noise('White Noise')
                det_noise = d_whinoise.generate_signal(m_start_time,
                                                       m_duration,
                                                       m_sample_rate,
                                                       detectors=[di])[0]
                gw_noise.append(det_noise)
            pop_logger.info('Generated White Noise background!')    
        if noise is None:
            # if noise is none, zero strain time series is given
            gw_noise = [GWSignal('No Noise', m_start_time, m_duration,
                        m_sample_rate, detector=di) for di in detectors]
            pop_logger.info('No Noise background generated!')
        return gw_noise[:]
        
    
    def generate_waveforms(self, start_time, duration, sample_rate,
                           detectors=['H1', 'L1', 'V1'], approximant=None,
                           lower_freq=40, verbose=50, noise=None):
        """Generate simulated starting signal, iterating over all sources
           given in input.
        """
        # First of all define an empy signal
        pop_logger.info('Simulation started!')

        gw_signal = self.generate_noise(start_time, duration, sample_rate,
                                        detectors=detectors, noise=noise)
        if self._elements == 0 and self.sources is None:
            pop_logger.info('Simulation concluded, no sources generated, only background selected!')         
            return gw_signal
        n_sources = {}
        count_sk = 0
        for i in range(len(self)):

            gw_single_source = self[i]
            gw_type = self.sources.iloc[i]['type']
            gw_name = self.sources.iloc[i]['id']
            numb_of_sources = len(self) - count_sk
            n_verbose = numb_of_sources // verbose
            
            if hasattr(gw_single_source, 'tp') or hasattr(gw_single_source, 't0'):
                try:
                    ssource_start = gw_single_source.tp - 0.5
                    ssource_end = gw_single_source.tp + 0.5
                    if gw_single_source.t_edge(np.pi/4) - gw_single_source.t_edge(-np.pi/4) < 1.:
                        ssource_start = gw_single_source.t_edge(-np.pi/4)
                        ssource_end = gw_single_source.t_edge(np.pi/4)
                except AttributeError:
                    ssource_start = gw_single_source.t0 - 10*gw_single_source.tau
                    ssource_end = gw_single_source.t0 + 10*gw_single_source.tau        
                if (ssource_start, ssource_end) < (start_time, start_time) or (ssource_start, ssource_end) > (start_time+duration, start_time+duration):
                    count_sk += 1
                    if count_sk == 1:
                        pop_logger.info('WARNING!! Some sources are skipped because out of time range!')  
                    continue          
            gw_signal_component = gw_single_source.generate_signal(start_time,
                                                                   duration, sample_rate,
                                                                   detectors=detectors,
                                                                   approximant=approximant,
                                                                   lower_freq=lower_freq)
            if i + 1 in list(range(verbose, (n_verbose + 1) * verbose, verbose)):
                # print(gw_single_source)
                pop_logger.info('Generated {} {} - {}/{}'.format(gw_type,
                                                                 gw_name, 
                                                                 i + 1, 
                                                                 numb_of_sources))
                # Sum over all signal generated and detectors
            for i in range(len(detectors)):
                gw_signal[i] += gw_signal_component[i]
                # Fill dictionary containing signal metadata
            try:
                n_sources[gw_type] += 1
            except KeyError:
                n_sources[gw_type] = 1
        # Add number and types of sources to signal metadata
        for k, v in list(n_sources.items()):
            for i in range(len(detectors)):
                gw_signal[i].name += ' {}{}'.format(v, k)                       
        pop_logger.info('Simulation concluded!')         
        return gw_signal    
            

    def __getitem__(self, index):
        """
        """
        if isinstance(index, slice):
            short_pop = self.__class__()
            try:
                short_pop.sources = self.sources.iloc[index] 
            except AttributeError:
                return self
            short_pop.name = '{}-{}'.format(short_pop.sources.iloc[0]['id'],
                                            short_pop.sources.iloc[-1]['id'])
            return short_pop                                                  
        else:

            if self.sources.iloc[index]['type'].startswith('GW'):
                s_type = self.sources.iloc[index]['type']
            else:
                s_type = 'GWPointSource'        
            MODULE = importlib.import_module('gwskysim.sources.'+\
                                             s_type.lower())
            class_ = getattr(MODULE, s_type)

            return class_.from_df(self.sources.iloc[index])

    def __str__(self):
        """
        Len of a gwpopulation is the number of sources
        """
        if self.sources is None:
            return "This is an empty GWPopulation instance"
        else:
            return '{} "{}": \n{}'.format(self.__class__.__name__,
                                          self.name, self.sources)         
        





